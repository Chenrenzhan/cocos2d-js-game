// Generated by CoffeeScript 1.10.0

/*
  水平的道具滑动选择条
 */

(function() {
  this.PropsScrollView = cc.Node.extend({
    mScrollView: null,
    mLength: 20,
    mScrollTimeStamp: 0,
    mClickTimeStamp: 0,
    mLongClickAction: null,
    mIsAction: false,
    mTouchTarget: null,
    mTouchDownY: 0,
    mTouchDownWidth: 0,
    ctor: function() {
      var layerMask;
      this._super();
      layerMask = new cc.LayerColor(cc.color(0, 0, 0, 150));
      layerMask.setContentSize(cc.winSize.width, 180);
      layerMask.attr({
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0
      });
      this.addChild(layerMask, 10);
      return this.initScrollView();
    },
    initScrollView: function() {
      var i, innerHeight, innerWidth, j, results, self, sprite;
      self = this;
      this.mScrollView = new ccui.ScrollView();
      this.mScrollView.setDirection(ccui.ScrollView.DIR_HORIZONTAL);
      this.mScrollView.setTouchEnabled(true);
      this.mScrollView.setBounceEnabled(true);
      this.mScrollView.setInertiaScrollEnabled(true);
      if (ccUtil.isNative()) {
        this.mScrollView.setScrollBarEnabled(false);
      }
      this.mScrollView.setContentSize(cc.size(cc.winSize.width, 180));
      this.mScrollView.attr({
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0
      });
      this.addChild(this.mScrollView, 5);
      this.mScrollView.addEventListener(function(touch, eventType) {
        return self.onScroll(touch, eventType);
      });
      results = [];
      for (i = j = 0; j < 20; i = ++j) {
        sprite = this.getItemView(resImg.props, i);
        innerWidth = sprite.x + sprite.getContentSize().width / 2 + 20;
        innerHeight = this.mScrollView.height;
        this.mScrollView.setInnerContainerSize(cc.size(innerWidth, innerHeight));
        results.push(this.mScrollView.addChild(sprite));
      }
      return results;
    },
    getItemView: function(res, index) {
      var label, sprite;
      sprite = new cc.Sprite(res);
      sprite.attr({
        anchorX: 0.5,
        anchorY: 0.5,
        x: sprite.width / 2 + (sprite.width + 20) * index + 20,
        y: sprite.height / 2 + 10
      });
      label = new cc.LabelTTF(index.toFixed(0), "Helvetica", 50.0);
      label.x = sprite.width / 2;
      label.y = sprite.height / 2;
      sprite.addChild(label, 0);
      sprite.setTag(index);
      cc.eventManager.addListener(this.onListener().clone(), sprite);
      return sprite;
    },
    onListener: function() {
      var self;
      self = this;
      return cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        swallowTouches: false,
        onTouchBegan: function(touch, event) {
          var locationInNode, rect, s, target;
          target = event.getCurrentTarget();
          locationInNode = target.convertToNodeSpace(touch.getLocation());
          s = target.getContentSize();
          rect = cc.rect(0, 0, s.width, s.height);
          if (cc.rectContainsPoint(rect, locationInNode)) {
            this.beginX = locationInNode.x;
            this.beginY = locationInNode.y;
            this.moveX = 5;
            this.moveY = 5;
            this.target = target;
            if (ccUtil.isNative()) {
              this.sx = self.mScrollView.getInnerContainerPosition().x;
              self.mClickTimeStamp = TimeUtil.getTimeStamp();
              self.mTouchTarget = target;
              self.scheduleOnce(self.onLongClick, 0.6, "123");
            }
            return true;
          }
          return false;
        },
        onTouchMoved: function(touch, event) {
          var stamp, target;
          target = event.getCurrentTarget();
          if (ccUtil.isNative()) {
            stamp = TimeUtil.getTimeStamp();
            if (Math.abs(self.mScrollView.getInnerContainerPosition().x - this.sx) > 5 || Math.abs(stamp - self.mClickTimeStamp) < 0.5) {
              return self.unschedule(self.onLongClick);
            }
          }
        },
        onTouchEnded: function(touch, event) {
          var endX, endY, locationInNode, t, target;
          target = event.getCurrentTarget();
          locationInNode = target.convertToNodeSpace(touch.getLocation());
          endX = locationInNode.x;
          endY = locationInNode.y;
          t = TimeUtil.getTimeStamp();
          if (Math.abs(endX - this.beginX) < this.moveX && Math.abs(endY - this.beginY) < this.moveY && Math.abs(t - self.mScrollTimeStamp) > 1000) {
            cc.log("sprite onTouchesEnded.. " + target.getTag());
          }
          self.mScrollTimeStamp = 0;
          if (ccUtil.isNative()) {
            self.unschedule(self.onLongClick);
            return self.onLongClickReverse();
          }
        }
      });
    },
    onScroll: function(touch, eventType) {
      return this.mScrollTimeStamp = TimeUtil.getTimeStamp();
    },
    onLongClick: function() {
      var moveBy, scaleBy;
      if (!this.mIsAction) {
        this.mTouchTarget.setLocalZOrder(100);
        this.mIsAction = true;
        this.mY = this.mTouchTarget.y;
        this.mWidth = this.mTouchTarget.width;
        moveBy = cc.moveBy(0.5, cc.p(0, 60));
        scaleBy = cc.scaleBy(0.5, 1.1);
        this.mLongClickAction = cc.spawn(moveBy, scaleBy);
        return this.mTouchTarget.runAction(this.mLongClickAction);
      }
    },
    onLongClickReverse: function() {
      var cw, cy, err, error, moveBy, scaleBy;
      if (this.mIsAction) {
        try {
          this.mTouchTarget.stopAction(this.mLongClickAction);
        } catch (error) {
          err = error;
          jlog.e(err);
        }
        cy = this.mTouchTarget.y;
        cw = this.mTouchTarget.getBoundingBox().width;
        moveBy = cc.moveBy(0.3, cc.p(0, Math.round(this.mY - cy)));
        scaleBy = cc.scaleBy(0.3, this.mWidth * 1.0 / cw);
        this.mIsAction = false;
        this.mTouchTarget.runAction(cc.spawn(moveBy, scaleBy));
        this.mTouchTarget.setLocalZOrder(100);
        return jlog.i("onLongClickReverse   " + this.mTouchTarget.getTag());
      }
    }
  });

  this.PropsTableView = cc.Node.extend({
    mTableView: null,
    mCellWidth: 0,
    mCellHeight: 0,
    ctor: function() {
      var layer;
      this._super();
      layer = new cc.LayerColor(cc.color(0, 0, 0, 150));
      layer.setContentSize(cc.winSize.width, 300);
      layer.attr({
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0
      });
      this.addChild(layer, 20);
      return this.initTableView();
    },
    initTableView: function() {
      var height, sprite, width;
      sprite = new cc.Sprite(resImg.HelloWorld_png);
      this.mCellWidth = sprite.width + 20;
      this.mCellHeight = sprite.height + 20;
      width = cc.winSize.width - 20;
      height = this.mCellHeight;
      jlog.d("width = " + width + "   ,   height = " + height);
      this.mTableView = new cc.TableView(this, cc.size(width, height));
      this.mTableView.setDirection(cc.SCROLLVIEW_DIRECTION_HORIZONTAL);
      this.mTableView.x = -110;
      this.mTableView.y = 20;
      this.mTableView.setDelegate(this);
      this.addChild(this.mTableView);
      return this.mTableView.reloadData();
    },
    scrollViewDidScroll: function(scrollview) {},
    scrollViewDidZoom: function(scrollview) {
      return jlog.i("scrollViewDidZoom");
    },
    updateCellAtIndex: function(index) {
      return jlog.i("updateCellAtIndex  " + index);
    },
    tableCellTouched: function(table, cell) {
      return jlog.i("cell touched at index: " + cell.getIdx());
    },
    tableCellSizeForIndex: function(table, idx) {
      if (idx === (this.numberOfCellsInTableView() - 1)) {
        return cc.size(this.mCellWidth - 20, 100);
      }
      return cc.size(this.mCellWidth, this.mCellHeight);
    },
    tableCellAtIndex: function(table, idx) {
      var cell, label, sprite, strValue;
      strValue = idx.toFixed(0);
      cell = table.dequeueCell();
      label;
      if (!cell) {
        cell = new cc.TableViewCell();
        sprite = new cc.Sprite(resImg.HelloWorld_png);
        sprite.setContentSize(60, 60);
        sprite.anchorX = 0;
        sprite.anchorY = 0;
        sprite.x = 0;
        sprite.y = 0;
        cell.addChild(sprite);
        label = new cc.LabelTTF(strValue, "Helvetica", 50.0);
        label.x = 100;
        label.y = 100;
        label.anchorX = 0;
        label.anchorY = 0;
        label.tag = 123;
        cell.addChild(label);
      } else {
        label = cell.getChildByTag(123);
        label.setString(strValue);
      }
      return cell;
    },
    numberOfCellsInTableView: function(table) {
      return 25;
    }
  });

}).call(this);

//# sourceMappingURL=PropsScrollView.js.map
