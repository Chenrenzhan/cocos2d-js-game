// Generated by CoffeeScript 1.10.0

/*
  棋盘
 */

(function() {
  this.ChessboardView = LayerBase.extend({
    mCells: null,
    mDownCell: null,
    mToCell: null,
    mCanSwapCells: true,
    mSwapCells: [],
    mCurStepSum: 0,
    mGoalColorIndex: 0,
    mInitGoalColorSum: 35,
    mCurGoalColorSum: 0,
    mGoalColorCells: [],
    mScore: 0,
    mChessColorRecord: [],
    mScoresRecord: [],
    mGoalColorSumRecord: [],
    mHadSelectMagic: false,
    mOnColorChange: null,
    mOnStepChange: null,
    mOnScoreChange: null,
    mReleaseMagicCb: null,
    ctor: function() {
      this._super();
      this.initSize();
      this.addCells();
      return cc.eventManager.addListener(this.onListener(), this);
    },
    setGoalColorSum: function(sum) {
      return this.mInitGoalColorSum = sum;
    },
    initSize: function() {
      this.ignoreAnchorPointForPosition(false);
      this.setAnchorPoint(cc.p(0.5, 0.5));
      return this.setContentSize(cc.winSize.width, cc.winSize.width);
    },
    addCells: function() {
      var colorIndex, i, j, l, node, ref, results;
      Configs.setCellSum(9, 9);
      this.mCells = [];
      results = [];
      for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        this.mCells[i] = [];
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
            colorIndex = GameUtil.getRandomInt(Configs.mColorSum - 1);
            node = ChessCell.create(colorIndex, i, j);
            this.mCells[i][j] = node;
            results1.push(this.addChild(node, 0));
          }
          return results1;
        }).call(this));
      }
      return results;
    },
    resetChess: function() {
      var colorIndex, i, j, l, m, ref, ref1;
      this.mScore = 0;
      this.mCurGoalColorSum = 0;
      this.mChessColorRecord = null;
      this.mScoresRecord.length = null;
      this.mGoalColorSumRecord = null;
      this.mSwapCells = null;
      this.mSwapCells = [];
      this.mChessColorRecord = [];
      this.mScoresRecord = [];
      this.mGoalColorSumRecord = [];
      for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          colorIndex = GameUtil.getRandomInt(Configs.mColorSum - 1);
          this.mCells[i][j].resetColor(colorIndex);
          this.mCells[i][j].unselect();
        }
      }
      this.scanAllCells();
      this.adjustTargetColor();
      this.scanOneColor(this.mGoalColorIndex, false);
      return this.adjustTargetColor();
    },
    onListener: function() {
      var self;
      self = this;
      return cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        swallowTouches: true,
        onTouchBegan: function(touch, event) {
          var downPoint, location, locationInNode, rect, ret, s, target, toPoint;
          target = event.getCurrentTarget();
          location = touch.getLocation();
          locationInNode = target.convertToNodeSpace(location);
          s = target.getContentSize();
          rect = cc.rect(0, 0, s.width, s.height);
          if (cc.rectContainsPoint(rect, locationInNode)) {
            this.lastX = location.x;
            this.lastY = location.y;
            ret = GameUtil.getIndexByLocation(location.x, location.y);
            if (self.mDownCell != null) {
              self.mDownCell.unselect();
            }
            if (ret.isInCell) {
              if (self.mHadSelectMagic) {
                self.mDownCell = self.mCells[ret.i][ret.j];
                if (self.mDownCell.mColorIndex !== self.mGoalColorIndex) {
                  self.mHadSelectMagic = false;
                  self.mReleaseMagicCb();
                  self.useMagic(self.mDownCell);
                  return false;
                }
                self.mHadSelectMagic = false;
                self.mReleaseMagicCb();
              }
              if (self.mDownCell != null) {
                if (GameUtil.isAdjacentSide(self.mDownCell.mX, self.mDownCell.mY, ret.i, ret.j) !== GameUtil.DIRECTION.none) {
                  self.mToCell = self.mCells[ret.i][ret.j];
                  downPoint = self.mDownCell.getPoint();
                  toPoint = self.mToCell.getPoint();
                  self.swapCells(self, downPoint, toPoint);
                  return false;
                }
              }
              self.mDownCell = self.mCells[ret.i][ret.j];
              self.mDownCell.select();
              self.mCanSwapCells = true;
              return true;
            }
            return false;
          }
          return false;
        },
        onTouchMoved: function(touch, event) {
          var direction, downCellPosition, downCellRect, downCellSize, downPoint, locationInNode, moveX, moveY, ret, target, toPoint;
          target = event.getCurrentTarget();
          moveX = touch.getLocationX();
          moveY = touch.getLocationY();
          if ((self.mDownCell != null) && ((Math.abs(moveX - this.lastX) > 5) || (Math.abs(moveY - this.lastY) > 5))) {
            locationInNode = target.convertToNodeSpace(touch.getLocation());
            downCellPosition = self.mDownCell.getPosition();
            downCellSize = self.mDownCell.getBoundingBox();
            downCellRect = cc.rect(downCellPosition.x, downCellPosition.y, downCellSize.width + Configs.mCellGap, downCellSize.height + Configs.mCellGap);
            if (!cc.rectContainsPoint(downCellRect, locationInNode)) {
              if ((!self.mToCell) && self.mCanSwapCells) {
                ret = GameUtil.getIndexByLocation(moveX, moveY);
                downPoint = cc.p(self.mDownCell.mX, self.mDownCell.mY);
                toPoint = cc.p(ret.i, ret.j);
                direction = GameUtil.relativePoint(downPoint, toPoint);
                toPoint = GameUtil.getSideCellByDirection(downPoint, direction);
                if (toPoint == null) {
                  return;
                }
                if (toPoint.x >= 0 && toPoint.x < Configs.mCellSumX && toPoint.y >= 0 && toPoint.y < Configs.mCellSumY) {
                  self.mToCell = self.mCells[toPoint.x][toPoint.y];
                  self.swapCells(self, downPoint, toPoint);
                }
                this.lastX = moveX;
                return this.lastY = moveY;
              }
            }
          }
        },
        onTouchEnded: function(touch, event) {
          var location, ret, target;
          target = event.getCurrentTarget();
          location = touch.getLocation();
          return ret = GameUtil.getIndexByLocation(location.x, location.y);
        }
      });
    },

    /*
      初始化扫描所以颜色块
     */
    scanAllCells: function() {
      var k, l, ref;
      for (k = l = 0, ref = Configs.mColorSum; 0 <= ref ? l < ref : l > ref; k = 0 <= ref ? ++l : --l) {
        if (k === this.mGoalColorIndex) {
          continue;
        }
        this.scanOneColor(k, false);
      }
      return this.scanOneColor(this.mGoalColorIndex, false);
    },

    /*
      重置扫描状态
     */
    resetScanState: function() {
      var i, j, l, ref, results;
      results = [];
      for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
            results1.push(this.mCells[i][j].mScanState = false);
          }
          return results1;
        }).call(this));
      }
      return results;
    },

    /*
      扫描一种颜色变色情况
     */
    scanOneColor: function(colorIndex, isScore) {
      var i, j, l, ref, results, surroundCells;
      colorIndex = parseInt(colorIndex);
      this.resetScanState();
      results = [];
      for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
            if (this.mCells[i][j].mScanState || parseInt(this.mCells[i][j].mColorIndex) === colorIndex) {
              this.mCells[i][j].mScanState = true;
              continue;
            }
            surroundCells = GameUtil.getSurroundCells(this.mCells, i, j, colorIndex);
            if (GameUtil.shouldChangeColor(surroundCells)) {
              results1.push(this.changeCellsColors(surroundCells, colorIndex, isScore));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    },

    /*
      调整目标颜色数目
     */
    adjustTargetColor: function() {
      this.mGoalColorCells = GameUtil.getGoalColorCells(this.mCells, this.mGoalColorIndex);
      if (this.mGoalColorCells.length < this.mInitGoalColorSum) {
        this.addTargetColorBlock();
      } else if (this.mGoalColorCells.length > this.mInitGoalColorSum) {
        this.removeTargetColorBlock();
      }
      return this.mCurGoalColorSum = this.mGoalColorCells.length;
    },

    /*
      添加一块目标颜色块
     */
    addTargetColorBlock: function() {
      var i, j, loseCount, results;
      loseCount = 0;
      results = [];
      while (this.mGoalColorCells.length < this.mInitGoalColorSum) {
        i = GameUtil.getRandomInt(Configs.mCellSumX);
        j = GameUtil.getRandomInt(Configs.mCellSumY);
        if (this.mCells[i][j].mColorIndex !== this.mGoalColorIndex && !GameUtil.hasSideColor(this.mCells, i, j, this.mGoalColorIndex)) {
          this.mCells[i][j].resetColor(this.mGoalColorIndex);
          results.push(this.mGoalColorCells.push({
            'i': i,
            'j': j
          }));
        } else {
          loseCount++;
          if (loseCount > (Configs.mCellSumX * Configs.mCellSumY * 2)) {
            results.push(this.resetChess());
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    },

    /*
      删除一块目标颜色块
     */
    removeTargetColorBlock: function() {
      var loseCount, randomInt, results, s;
      loseCount = 0;
      results = [];
      while (this.mGoalColorCells.length > this.mInitGoalColorSum) {
        randomInt = GameUtil.getRandomInt(this.mGoalColorCells.length);
        s = this.mGoalColorCells[randomInt];
        if (GameUtil.hasNotSideColor(this.mCells, s.i, s.j, this.mGoalColorIndex)) {
          this.mCells[s.i][s.j].resetColor(Configs.mColorSum - 1);
          results.push(this.mGoalColorCells.splice(randomInt, 1));
        } else {
          loseCount++;
          if (loseCount > (Configs.mCellSumX * Configs.mCellSumY * 2)) {
            results.push(this.resetChess());
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    },

    /*
      改变颜色,isScore是否计分
     */
    changeCellsColors: function(surroundCells, colorIndex, isScore) {
      var i, j, l, len, n, results, site;
      n = surroundCells.length;
      colorIndex = parseInt(colorIndex);
      if (isScore && colorIndex === this.mGoalColorIndex) {
        AudioManager.playTurnAudio();
        this.mScore += GameUtil.scoringFormula(n);
        this.mOnScoreChange(this.mScore);
        this.mCurGoalColorSum += surroundCells.length;
        this.mOnColorChange(this.mCurGoalColorSum);
      }
      results = [];
      for (l = 0, len = surroundCells.length; l < len; l++) {
        site = surroundCells[l];
        i = site.i;
        j = site.j;
        results.push(this.mCells[i][j].resetColor(colorIndex, isScore));
      }
      return results;
    },
    swapCells: function(self, downPoint, toPoint, isBack) {
      var cbFunc, extracted;
      extracted = function() {
        GameUtil.swapTwoCells(self.mDownCell, self.mToCell, cbFunc);
        self.mCells[toPoint.x][toPoint.y] = self.mDownCell;
        self.mDownCell.setLocalZOrder(0);
        self.mCells[toPoint.x][toPoint.y].setXY(toPoint.x, toPoint.y);
        self.mCells[downPoint.x][downPoint.y] = self.mToCell;
        return self.mCells[downPoint.x][downPoint.y].setXY(downPoint.x, downPoint.y);
      };
      if (self.mDownCell != null) {
        AudioManager.playTranspkAudio();
        self.mDownCell.unselect();
        cbFunc = function() {
          var i, l, length, p, ref, results;
          length = self.mSwapCells.length > 10 ? 10 : self.mSwapCells.length;
          if (length <= 0) {
            return;
          }
          results = [];
          for (i = l = 1, ref = length; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
            p = self.mSwapCells[self.mSwapCells.length - i];
            if (p === false) {
              continue;
            }
            results.push(self.mCells[p.x][p.y].resetPosition());
          }
          return results;
        };
        if (!((isBack != null) && isBack)) {
          extracted();
          if (self.mDownCell.mColorIndex !== self.mToCell.mColorIndex) {
            self.mCurStepSum--;
            self.recordLastStep(downPoint, toPoint);
          }
          self.scanOneColor(self.mDownCell.mColorIndex, true);
          self.scanOneColor(self.mToCell.mColorIndex, true);
        } else {
          extracted();
          self.restoreLastStep();
          if (self.mDownCell.mColorIndex !== self.mToCell.mColorIndex) {
            self.mCurStepSum++;
          }
        }
        jlog.i(" self.mCurStepSum = " + self.mCurStepSum);
        self.mOnStepChange(self.mCurStepSum);
        self.mToCell = null;
        return self.mDownCell = null;
      }
    },
    recordLastStep: function(downPoint, toPoint) {
      var i, j, l, lastCellsColor, m, ref, ref1;
      lastCellsColor = null;
      lastCellsColor = [];
      for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        lastCellsColor[i] = [];
        for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          lastCellsColor[i][j] = this.mCells[i][j].mColorIndex;
        }
      }
      this.mSwapCells.push(downPoint);
      this.mSwapCells.push(toPoint);
      this.mChessColorRecord.push(lastCellsColor);
      this.mScoresRecord.push(this.mScore);
      return this.mGoalColorSumRecord.push(this.mCurGoalColorSum);
    },
    restoreLastStep: function() {
      var i, j, l, lastCellsColor, m, ref, ref1;
      if (this.mChessColorRecord.length > 0) {
        lastCellsColor = this.mChessColorRecord.pop();
        for (i = l = 0, ref = Configs.mCellSumX; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          for (j = m = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
            this.mCells[i][j].resetColor(lastCellsColor[i][j]);
          }
        }
      }
      if (this.mScoresRecord.length > 0) {
        this.mScore = this.mScoresRecord.pop();
        this.mOnScoreChange(this.mScore);
      }
      if (this.mGoalColorSumRecord.length > 0) {
        this.mCurGoalColorSum = this.mGoalColorSumRecord.pop();
        return this.mOnColorChange(this.mCurGoalColorSum);
      }
    },
    setOnStepChange: function(callback) {
      return this.mOnStepChange = callback;
    },
    setOnScoreChange: function(callback) {
      return this.mOnScoreChange = callback;
    },
    setOnColorChange: function(callback) {
      return this.mOnColorChange = callback;
    },
    setStepSum: function(stepSum) {
      this.mCurStepSum = stepSum;
      return jlog.i("@mCurStepSum = " + this.mCurStepSum);
    },
    backOneStep: function() {
      var downPoint, toPoint;
      toPoint = this.mSwapCells.pop();
      downPoint = this.mSwapCells.pop();
      if ((toPoint === false) || (downPoint === false)) {
        this.restoreLastStep();
        return false;
      }
      this.mDownCell = this.mCells[downPoint.x][downPoint.y];
      this.mToCell = this.mCells[toPoint.x][toPoint.y];
      this.swapCells(this, downPoint, toPoint, true);
      if (ccUtil.isNative()) {
        return umeng.MobClickCpp.use("props-1", 1, 2);
      }
    },
    useMagic: function(downCell) {
      this.recordLastStep(false, false);
      downCell.resetColor(this.mGoalColorIndex);
      this.mScore += GameUtil.scoringFormula(1);
      this.mOnScoreChange(this.mScore);
      this.mCurGoalColorSum++;
      this.mOnColorChange(this.mCurGoalColorSum);
      this.scanOneColor(this.mGoalColorIndex, true);
      if (ccUtil.isNative()) {
        return umeng.MobClickCpp.use("props-0", 1, 2);
      }
    },
    selectMagic: function() {
      return this.mHadSelectMagic = true;
    },
    setReleaseMagicCb: function(cb) {
      return this.mReleaseMagicCb = cb;
    }
  });

}).call(this);

//# sourceMappingURL=ChessboardView.js.map
