// Generated by CoffeeScript 1.10.0

/*
  弹出框基类
 */

(function() {
  this.PopLayerBase = cc.Layer.extend({
    mListener: null,
    mBgLayer: null,
    mMask: null,
    mIsPophidden: false,
    mIsTouchBgHide: true,
    mIsShowPopBegin: true,
    mHiddenCallback: null,
    mShowCallback: null,
    ctor: function() {
      this._super();
      this.setLocalZOrder(10000);
      this.ignoreAnchorPointForPosition(false);
      this.setContentSize(cc.winSize);
      this.setPosition(cc.p(cc.winSize.width / 2, cc.winSize.height / 2));
      return this.visible = this.mIsShowPopBegin;
    },
    markLayer: function(color) {
      if (ccUtil.isObjectNotNull(color)) {
        this.mMask = new cc.LayerColor(color);
        return this.addChild(this.mMask);
      }
    },
    addListener: function() {
      var self;
      self = this;
      this.mListener = cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        swallowTouches: true,
        onTouchBegan: function(touch, event) {
          var locationInNode, rect, s, target;
          if (self.mIsTouchBgHide) {
            target = event.getCurrentTarget();
            locationInNode = target.convertToNodeSpace(touch.getLocation());
            s = target.getContentSize();
            rect = cc.rect(0, 0, s.width, s.height);
            if (!cc.rectContainsPoint(rect, locationInNode)) {
              self.mIsPophidden = true;
              self.hidden(self.mHiddenCallback);
              return false;
            } else {
              return true;
            }
          } else {
            return true;
          }
        },
        onTouchEnded: function(touch, event) {
          if (self.mIsTouchBgHide && self.mIsPophidden) {
            self.deleteListener();
            self.mIsPophidden = false;
            return false;
          }
        }
      });
      return cc.eventManager.addListener(this.mListener, this.mBgLayer);
    },
    deleteListener: function() {
      return cc.eventManager.removeListener(this.mListener);
    },
    show: function(cbFun) {
      var fadeIn, func, scaleTo, self, seq;
      self = this;
      this.visible = true;
      if (this.mMask != null) {
        fadeIn = new cc.FadeTo(0.2, 120);
        this.mMask.runAction(fadeIn);
      }
      this.mBgLayer.scale = 0;
      scaleTo = new cc.ScaleTo(0.4, 1).easing(cc.easeElasticOut(0.7));
      func = ccUtil.callFunc(cbFun, "show dialog");
      seq = new cc.Sequence(scaleTo, func);
      this.mBgLayer.runAction(seq);
      return this.addListener();
    },
    hidden: function(cbFun) {
      var fadeOut, fun, func, scaleTo, self, seq;
      self = this;
      scaleTo = new cc.ScaleTo(0.4, 0).easing(cc.easeElasticOut(1.2));
      self = this;
      fun = function() {
        if (ccUtil.isFunction(cbFun)) {
          cbFun();
        }
        return self.removeFromParent(true);
      };
      func = ccUtil.callFunc(fun, "hidden dialog");
      seq = new cc.Sequence(scaleTo, func);
      this.mBgLayer.runAction(seq);
      if (this.mMask != null) {
        fadeOut = new cc.FadeOut(0.2);
        return this.mMask.runAction(fadeOut);
      }
    },
    setTouchbgHide: function(flag) {
      return this.mIsTouchBgHide = flag;
    },
    setHiddenCallback: function(fun) {
      return this.mHiddenCallback = fun;
    },
    setShowCallback: function(fun) {
      return this.mShowCallback = fun;
    }
  });

}).call(this);

//# sourceMappingURL=PopLayerBase.js.map
