// Generated by CoffeeScript 1.10.0

/*
  游戏规则工具类
 */

(function() {
  this.GameUtil = {
    DIRECTION: {
      left: 0,
      up: 1,
      right: 2,
      down: 3,
      none: -1
    },
    getRandomInt: function(max) {
      return Math.floor(Math.random() * max);
    },
    getIndexByLocation: function(x, y) {
      var endY, gapBeginX, gapBeginY, i, j, ret, startY;
      ret = {
        'isInCell': false,
        'i': -1,
        'j': -1
      };
      startY = 200;
      endY = startY + cc.winSize.width;
      if (y < (startY + Configs.mBorderY) || y > (endY - Configs.mBorderY)) {
        return ret;
      }
      if (x < Configs.mBorderX || x > (cc.winSize.width - Configs.mBorderX)) {
        return ret;
      }
      i = (x - Configs.mBorderX) / (Configs.mCellWidth + Configs.mCellGap);
      i = Math.floor(i);
      gapBeginX = Configs.mBorderX + i * (Configs.mCellWidth + Configs.mCellGap) + Configs.mCellWidth;
      j = (y - startY - Configs.mBorderY) / (Configs.mCellWidth + Configs.mCellGap);
      j = Math.floor(j);
      gapBeginY = startY + Configs.mBorderY + j * (Configs.mCellWidth + Configs.mCellGap) + Configs.mCellWidth;
      ret = {
        'isInCell': false,
        'i': i,
        'j': j
      };
      if (x > gapBeginX || i >= Configs.mCellSumX) {
        return ret;
      }
      if (y > gapBeginY || j >= Configs.mCellSumY) {
        return ret;
      }
      ret = {
        'isInCell': true,
        'i': i,
        'j': j
      };
      return ret;
    },
    isAdjacentSide: function(i1, j1, i2, j2) {
      if (i1 === i2) {
        if ((j1 - j2) === 1) {
          return this.DIRECTION.left;
        } else if ((j2 - j1) === 1) {
          return this.DIRECTION.right;
        }
      } else if (j1 === j2) {
        if ((i1 - i2) === 1) {
          return this.DIRECTION.left;
        } else if ((i2 - i1) === 1) {
          return this.DIRECTION.right;
        }
      }
      return this.DIRECTION.none;
    },
    relativePoint: function(point1, point2) {
      var rate;
      if (point1.x < 0 || point1.y < 0 || point2.x < 0 || point2.y < 0) {
        return this.DIRECTION.none;
      }
      rate = (point2.y - point1.y) / (point2.x - point1.x);
      if ((rate > -1) && (rate < 1)) {
        if (point2.x > point1.x) {
          return this.DIRECTION.right;
        } else if (point2.x < point1.x) {
          return this.DIRECTION.left;
        }
      } else if ((rate < -1) || (rate > 1)) {
        if (point2.y > point1.y) {
          return this.DIRECTION.up;
        } else if (point2.y < point1.y) {
          return this.DIRECTION.down;
        }
      }
      return this.DIRECTION.none;
    },
    getSideCellByDirection: function(point, direction) {
      var i, j;
      i = point.x;
      j = point.y;
      switch (direction) {
        case GameUtil.DIRECTION.left:
          i--;
          break;
        case GameUtil.DIRECTION.up:
          j++;
          break;
        case GameUtil.DIRECTION.right:
          i++;
          break;
        case GameUtil.DIRECTION.down:
          j--;
          break;
        case GameUtil.DIRECTION.none:
          return null;
      }
      return cc.p(i, j);
    },
    swapTwoCells: function(downCell, toCell, cbFunc) {
      downCell.setLocalZOrder(5);
      downCell.runAction(ActionManager.swapCellsAction(toCell.getPosition()));
      return toCell.runAction(ActionManager.swapCellsAction(downCell.getPosition(), cbFunc));
    },

    /*
      以(x, y)作为起点进行扫描被colorIndex颜色包围住的所有颜色块
     */
    getSurroundCells: function(cells, x, y, colorIndex) {
      var queue, site, surroundCells;
      x = parseInt(x);
      y = parseInt(y);
      colorIndex = parseInt(colorIndex);
      queue = [];
      surroundCells = [];
      cells[x][y].mScanState = true;
      queue.push({
        'i': x,
        'j': y
      });
      while (queue.length > 0) {
        site = queue.shift();
        x = site.i;
        y = site.j;
        if ((y - 1 >= 0) && (parseInt(cells[x][y - 1].mColorIndex) !== colorIndex) && (!cells[x][y - 1].mScanState)) {
          cells[x][y - 1].mScanState = true;
          queue.push({
            'i': x,
            'j': y - 1
          });
        }
        if ((x - 1 >= 0) && (parseInt(cells[x - 1][y].mColorIndex) !== colorIndex) && (!cells[x - 1][y].mScanState)) {
          cells[x - 1][y].mScanState = true;
          queue.push({
            'i': x - 1,
            'j': y
          });
        }
        if ((y + 1 < Configs.mCellSumY) && (parseInt(cells[x][y + 1].mColorIndex) !== colorIndex) && (!cells[x][y + 1].mScanState)) {
          cells[x][y + 1].mScanState = true;
          queue.push({
            'i': x,
            'j': y + 1
          });
        }
        if ((x + 1 < Configs.mCellSumX) && (parseInt(cells[x + 1][y].mColorIndex) !== colorIndex) && (!cells[x + 1][y].mScanState)) {
          cells[x + 1][y].mScanState = true;
          queue.push({
            'i': x + 1,
            'j': y
          });
        }
        surroundCells.push(site);
      }
      return surroundCells;
    },

    /*
      分情况判断是否变色
     */
    shouldChangeColor: function(surroundCells) {
      var down, k, l, left, len, len1, minEdge, notZeroCount, ref, right, side, site, up;
      minEdge = Configs.mCellSumX > Configs.mCellSumY ? Configs.mCellSumX : Configs.mCellSumY;
      if (surroundCells.length < minEdge / 2 + 1) {
        return true;
      } else {
        left = 0;
        right = 0;
        up = 0;
        down = 0;
        for (k = 0, len = surroundCells.length; k < len; k++) {
          site = surroundCells[k];
          if (site.i === 0) {
            left++;
          }
          if (site.i === (Configs.mCellSumX - 1)) {
            right++;
          }
          if (site.j === (Configs.mCellSumY - 1)) {
            up++;
          }
          if (site.j === 0) {
            down++;
          }
        }
        notZeroCount = 0;
        ref = [left, up, right, down];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          side = ref[l];
          if (side === 0) {
            notZeroCount++;
          }
        }
        if (notZeroCount > 2) {
          return false;
        } else if (left + right + up + down > ((Configs.mCellSumX + Configs.mCellSumY) / 2)) {
          return false;
        } else {
          return true;
        }
      }
    },

    /*
      获取某颜色单元块
     */
    getGoalColorCells: function(cells, color) {
      var goalColorCells, i, j, k, l, ref, ref1;
      goalColorCells = [];
      for (i = k = 0, ref = Configs.mCellSumX; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        for (j = l = 0, ref1 = Configs.mCellSumY; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          if (cells[i][j].mColorIndex === color) {
            goalColorCells.push({
              'i': i,
              'j': j
            });
          }
        }
      }
      return goalColorCells;
    },

    /*
      判断某一点的周围(上下左右对角线八个点)是否有colorIndex一种颜色
     */
    hasSideColor: function(cells, i, j, colorIndex) {
      var count;
      count = 0;
      if (this.isEdge(i, j)) {
        count++;
      }
      if ((i - 1 >= 0) && (j - 1 >= 0) && cells[i - 1][j - 1].mColorIndex === colorIndex) {
        return true;
      } else if ((i - 1 >= 0) && cells[i - 1][j].mColorIndex === colorIndex) {
        return count++;
      } else if ((i - 1 >= 0) && (j + 1 < Configs.mCellSumY) && cells[i - 1][j + 1].mColorIndex === colorIndex) {
        return true;
      } else if ((j - 1 >= 0) && cells[i][j - 1].mColorIndex === colorIndex) {
        return count++;
      } else if ((j + 1 < Configs.mCellSumY) && cells[i][j + 1].mColorIndex === colorIndex) {
        return count++;
      } else if ((i + 1 < Configs.mCellSumX) && (j - 1 >= 0) && cells[i + 1][j - 1].mColorIndex === colorIndex) {
        return true;
      } else if ((i + 1 < Configs.mCellSumX) && cells[i + 1][j].mColorIndex === colorIndex) {
        return count++;
      } else if ((i + 1 < Configs.mCellSumX) && (j + 1 < Configs.mCellSumY) && cells[i + 1][j + 1].mColorIndex === colorIndex) {
        return true;
      } else if (count > 1) {
        return true;
      } else {
        return false;
      }
    },

    /*
      判断周围是否有非目标颜色块
     */
    hasNotSideColor: function(cells, i, j, colorIndex) {
      if (this.isEdge(i, j)) {
        return false;
      }
      if (cells[i - 1][j].mColorIndex !== colorIndex) {
        return true;
      } else if (cells[i][j - 1].mColorIndex !== colorIndex) {
        return true;
      } else if (cells[i][j + 1].mColorIndex !== colorIndex) {
        return true;
      } else if (cells[i + 1][j].mColorIndex !== colorIndex) {
        return true;
      } else {
        return false;
      }
    },

    /*
      判断（i, j）点是否在边界
     */
    isEdge: function(i, j) {
      if ((i === 0) || (i === Configs.mCellSumX - 1) || (j === 0) || (j === Configs.mCellSumY - 1)) {
        return true;
      } else {
        return false;
      }
    },
    scoringFormula: function(n) {
      var score;
      score = n === 1 ? 100 : (100 + 100 + (n - 1) * 20) * n / 2;
      return score;
    },
    getFromFormula: function(level, key, formula, defaultValue) {
      var bigLevel, e, error, i, jsonObj, sum, value;
      bigLevel = Math.floor(level / 10);
      value = parseInt(Configs.mSettings[Keys.LEVELS][bigLevel][key]);
      if (value <= 0) {
        return defaultValue;
      } else {
        i = level % 10;
        jsonObj = Configs.mSettings;
        sum = value;
        try {
          return sum = eval(jsonObj[Keys.LEVELS][bigLevel][formula]);
        } catch (error) {
          e = error;
          jlog.e(e);
          return sum = value;
        } finally {
          return sum;
        }
      }
    },
    getGoalColorSum: function(level) {
      return this.getFromFormula(level, Keys.GOAL_SUM, Keys.SUM_FORMULA, 20);
    },
    getLimitStep: function(level) {
      return this.getFromFormula(level, Keys.LIMIT_STEP, Keys.STEP_FORMULA, false);
    },
    getLimitScore: function(level) {
      return this.getFromFormula(level, Keys.GOAL_SCORE, Keys.SCORE_FORMULA, false);
    },
    getLimitTime: function(level) {
      return this.getFromFormula(level, Keys.LIMIT_TIME, Keys.TIME_FORMULA, false);
    }
  };

}).call(this);

//# sourceMappingURL=GameUtil.js.map
