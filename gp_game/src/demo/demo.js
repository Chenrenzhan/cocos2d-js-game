// Generated by CoffeeScript 1.10.0
(function() {
  this.colors = ["#0000ff", "#ff7f50", "#7fff00", "#deb887", "#8a2be2", "#d2691e", "#6495ed", "#a52a2a2a"];

  this.colorsSum = 6;

  this.targetColor = 0;

  this.timer = null;

  this.targetColorSum = 0;

  this.mShape = {
    checked: true,
    i: 9,
    j: 9
  };

  this.mBlock = {
    checked: true,
    sum: 20
  };

  this.mStep = {
    checked: true,
    sum: 30
  };

  this.mTime = {
    checked: false,
    sum: 100
  };

  this.cells = [];

  this.targetColorCells = [];

  this.cellFlag = {
    color: 0,
    hadScan: false
  };

  this.cell = {
    color: 0,
    cellFlags: []
  };

  this.ready = function() {
    return generateChessBoard();
  };

  this.initArray = function() {
    var i, m, ref;
    this.cells = null;
    this.cells = [];
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      this.cells[i] = null;
      this.cells[i] = [];
    }
    this.targetColorCells = null;
    return this.targetColorCells = [];
  };

  this.initParam = function() {
    this.targetColorSum = 0;
    this.mShape.checked = $('#cb_shape').is(':checked');
    this.mShape.i = parseInt($('#shape_i').val());
    this.mShape.j = parseInt($('#shape_j').val());
    this.mBlock.checked = $('#cb_block').is(':checked');
    this.mBlock.sum = parseInt($('#block_sum').val());
    this.mStep.checked = $('#cb_step').is(':checked');
    this.mStep.sum = parseInt($('#step_sum').val());
    this.mTime.checked = $('#cb_time').is(':checked');
    return this.mTime.sum = parseInt($('#time_sum').val());
  };

  this.generateChessBoard = function() {
    var i, j, m, o, ref, ref1, table, td, td_id, tr;
    initParam();
    initArray();
    table = $('<table align=\"center\"></table>');
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      tr = $('<tr></tr>');
      for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
        td = $('<td></td>');
        td.addClass('true');
        td_id = 'td-' + i + '-' + j;
        td.attr('id', td_id);
        td.addClass("cell");
        td.appendTo(tr);
      }
      tr.appendTo(table);
    }
    $('#container').html("");
    table.appendTo($('#container'));
    randColor();
    return play();
  };

  this.randColor = function() {
    var cf, cl, i, id, j, k, m, o, p, random, randomInt, ref, ref1, ref2;
    random = Math.random() * (this.colorsSum - 1);
    randomInt = Math.floor(random);
    this.targetColor = randomInt;
    $('#reset').css('background', 'black');
    $('#reset').css('background', colors[randomInt]);
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
        random = Math.random() * (this.colorsSum - 1);
        randomInt = Math.floor(random);
        cl = JSON.parse(JSON.stringify(this.cell));
        cl.color = randomInt;
        for (k = p = 0, ref2 = this.colorsSum; 0 <= ref2 ? p < ref2 : p > ref2; k = 0 <= ref2 ? ++p : --p) {
          cf = JSON.parse(JSON.stringify(this.cellFlag));
          cf.color = k;
          cl.cellFlags[k] = cf;
        }
        this.cells[i][j] = cl;
        id = "#td-" + i + "-" + j;
        $(id).css("background", colors[randomInt]);
        $(id).html(randomInt);
      }
    }
    scanChange();
    adjustTargetColor();
    checkOneColor(this.targetColor, true);
    resetScanState(this.targetColor);
    countColorSum(this.targetColor);
    adjustTargetColor();
    $('#score').html(0);
    if (this.mTime.checked) {
      $('#countdown').html(this.mTime.sum);
    } else {
      $('#countdown').html(0);
    }
    if (!this.mStep.checked) {
      $('#step').html(0);
    } else {
      $('#step').html(this.mStep.sum);
    }
    return startTimer();
  };


  /*
    统计一种颜色数目
   */

  this.countColorSum = function(color) {
    var count, i, j, m, o, ref, ref1;
    count = 0;
    this.targetColorCells = null;
    this.targetColorCells = [];
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
        if (this.cells[i][j].color === color) {
          this.targetColorCells.push({
            'i': i,
            'j': j
          });
          count++;
        }
      }
    }
    return count;
  };


  /*
    调整目标颜色数目
   */

  this.adjustTargetColor = function() {
    countColorSum(this.targetColor);
    console.log("@targetColorCells.length 000 = " + this.targetColorCells.length);
    if (this.targetColorCells.length < this.mBlock.sum) {
      addTargetColorBlock();
    } else if (this.targetColorCells.length > this.mBlock.sum) {
      removeTargetColorBlock();
    }
    this.targetColorSum = this.targetColorCells.length;
    return console.log("@targetColorCells.length = " + this.targetColorCells.length);
  };


  /*
    添加一块目标颜色块
   */

  this.addTargetColorBlock = function() {
    var count, i, id, j, results;
    count = 0;
    results = [];
    while (this.targetColorCells.length < this.mBlock.sum) {
      i = Math.floor(Math.random() * this.mShape.i);
      j = Math.floor(Math.random() * this.mShape.j);
      if (this.cells[i][j].color !== this.targetColor && !hasAdjoinColor(i, j, this.targetColor)) {
        id = structId(i, j);
        setColor(id, this.colors[this.targetColor], this.targetColor);
        results.push(this.targetColorCells.push({
          'i': i,
          'j': j
        }));
      } else {
        count++;
        if (count > (this.mShape.i * this.mShape.j * 2)) {
          results.push(generateChessBoard());
        } else {
          results.push(void 0);
        }
      }
    }
    return results;
  };


  /*
    删除一块目标颜色块
   */

  this.removeTargetColorBlock = function() {
    var count, id, location, random, randomInt, results;
    count = 0;
    results = [];
    while (this.targetColorCells.length > this.mBlock.sum) {
      random = Math.random() * this.targetColorCells.length;
      randomInt = Math.floor(random);
      location = this.targetColorCells[randomInt];
      if (hasNotColorSide(location.i, location.j, this.targetColor)) {
        id = structId(location.i, location.j);
        setColor(id, this.colors[this.colorsSum - 1], this.colorsSum - 1);
        results.push(this.targetColorCells.splice(randomInt, 1));
      } else {
        count++;
        if (count > (this.mShape.i * this.mShape.j * 2)) {
          results.push(generateChessBoard());
        } else {
          results.push(void 0);
        }
      }
    }
    return results;
  };


  /*
    判读周围是否有非目标颜色块
   */

  this.hasNotColorSide = function(i, j, colorIndex) {
    i = parseInt(i);
    j = parseInt(j);
    if (isSide(i, j)) {
      return false;
    }
    if ((i - 1 >= 0) && this.cells[i - 1][j].color !== colorIndex) {
      return true;
    } else if ((j - 1 >= 0) && this.cells[i][j - 1].color !== colorIndex) {
      return true;
    } else if ((j + 1 < this.mShape.j) && this.cells[i][j + 1].color !== colorIndex) {
      return true;
    } else if ((i + 1 < this.mShape.i) && this.cells[i + 1][j].color !== colorIndex) {
      return true;
    } else {
      return false;
    }
  };


  /*
    判断某一点的周围是否有同一种颜色
   */

  this.hasAdjoinColor = function(i, j, color) {
    var direct;
    direct = 0;
    if (isSide(i, j)) {
      direct++;
    }
    if ((i - 1 >= 0) && (j - 1 >= 0) && this.cells[i - 1][j - 1].color === color) {
      return true;
    } else if ((i - 1 >= 0) && this.cells[i - 1][j].color === color) {
      return direct++;
    } else if ((i - 1 >= 0) && (j + 1 < this.mShape.j) && this.cells[i - 1][j + 1].color === color) {
      return true;
    } else if ((j - 1 >= 0) && this.cells[i][j - 1].color === color) {
      return direct++;
    } else if ((j + 1 < this.mShape.j) && this.cells[i][j + 1].color === color) {
      return direct++;
    } else if ((i + 1 < this.mShape.i) && (j - 1 >= 0) && this.cells[i + 1][j - 1].color === color) {
      return true;
    } else if ((i + 1 < this.mShape.i) && this.cells[i + 1][j].color === color) {
      return direct++;
    } else if ((i + 1 < this.mShape.i) && (j + 1 < this.mShape.j) && this.cells[i + 1][j + 1].color === color) {
      return true;
    } else if (direct > 1) {
      return true;
    } else {
      return false;
    }
  };

  this.isSide = function(i, j) {
    if ((i === 0) || (i === this.mShape.i - 1) || (j === 0) || (j === this.mShape.j - 1)) {
      return true;
    } else {
      return false;
    }
  };

  this.play = function() {
    var downColor, downId, i, id, isDown, j, m, ref, results, upColor, upId;
    isDown = false;
    downColor = "#000000";
    downId = "";
    upColor = "#000000";
    upId = "";
    results = [];
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      results.push((function() {
        var o, ref1, results1;
        results1 = [];
        for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
          id = "#td-" + i + "-" + j;
          results1.push($(id).bind({
            selectstart: function(e) {
              return false;
            },
            mousedown: function(e) {
              isDown = true;
              downId = getIdFromEvent(e);
              return false;
            },
            mouseup: function(e) {
              var downTag, upTag;
              if (!isDown) {
                return false;
              }
              isDown = false;
              upId = getIdFromEvent(e);
              if (!isAdjacent(downId, upId)) {
                return false;
              }
              downColor = getColor(downId);
              upColor = getColor(upId);
              downTag = getTag(downId);
              upTag = getTag(upId);
              if (downColor !== upColor) {
                setColor(downId, upColor, upTag);
                setColor(upId, downColor, downTag);
                stepIncreate();
                checkOneColor(downTag, true);
                checkOneColor(upTag, true);
                resetScanState(downTag);
                resetScanState(upTag);
                if (isGameComplete()) {
                  return gameComplete();
                }
              }
            }
          }));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  this.getIdFromEvent = function(event) {
    return event.currentTarget.id;
  };

  this.getTag = function(id) {
    return $("#" + id).html();
  };

  this.getColor = function(id) {
    return $("#" + id).css("background");
  };

  this.setColor = function(id, color, tag) {
    var ids;
    $("#" + id).css("background", color);
    $("#" + id).html(tag);
    ids = id.split("-");
    return this.cells[ids[1]][ids[2]].color = tag;
  };

  this.structId = function(i, j) {
    return "td-" + i + "-" + j;
  };


  /*
    是否相邻
   */

  this.isAdjacent = function(downId, upId) {
    var down, up;
    down = downId.split('-');
    up = upId.split('-');
    if ((down[1] === up[1] && Math.abs(down[2] - up[2]) === 1) || (down[2] === up[2] && Math.abs(down[1] - up[1]) === 1)) {
      return true;
    } else {
      return false;
    }
  };


  /*
    开始计时
   */

  this.startTimer = function() {
    var err, error, error1;
    if (!this.mTime.checked) {
      $('#countdown').html(0);
      try {
        clearInterval(this.timer);
      } catch (error) {
        err = error;
        console.error(err);
      }
      return this.timer = setInterval(function() {
        var t;
        t = parseInt($('#countdown').html());
        t++;
        return $('#countdown').html(t);
      }, 1000);
    } else {
      $('#countdown').html(this.mTime.sum);
      try {
        clearInterval(this.timer);
      } catch (error1) {
        err = error1;
        console.error(err);
      }
      return this.timer = setInterval(function() {
        var error2, t;
        t = parseInt($('#countdown').html());
        t--;
        $('#countdown').html(t);
        if (t <= 0) {
          gameOver();
          try {
            return clearInterval(this.timer);
          } catch (error2) {
            err = error2;
            return console.error(err);
          }
        }
      }, 1000);
    }
  };


  /*
    步骤增加
   */

  this.stepIncreate = function(sum) {
    var count;
    if (sum == null) {
      sum = 1;
    }
    if (!this.mStep.checked) {
      count = parseInt($('#step').html());
      count += sum;
      return $('#step').html(count);
    } else {
      count = parseInt($('#step').html());
      count -= sum;
      $('#step').html(count);
      if (count <= 0) {
        return gameOver();
      }
    }
  };


  /*
    游戏结束
   */

  this.gameOver = function() {
    var msg;
    msg = "游戏结束\n";
    if (this.mStep.checked) {
      msg += "剩余步骤为: " + $('#step').html() + "\n";
    } else {
      msg += "使用步数为： " + $('#step').html() + "\n";
    }
    if (this.mTime.checked) {
      msg += "剩余时间为: " + $('#countdown').html() + "\n";
    } else {
      msg += "使用时间为： " + $('#countdown').html() + "\n";
    }
    msg += "得分为： " + $('#score').html() + "\n";
    return alert(msg);
  };


  /*
    判断游戏是否通关
   */

  this.isGameComplete = function() {
    if (this.targetColorSum < this.mShape.i * this.mShape.j) {
      return false;
    }
    return true;
  };


  /*
    游戏通关
   */

  this.gameComplete = function() {
    var msg;
    msg = "游戏通关\n";
    if (this.mStep.checked) {
      msg += "剩余步骤为: " + $('#step').html() + "\n";
    } else {
      msg += "使用步数为： " + $('#step').html() + "\n";
    }
    if (this.mTime.checked) {
      msg += "剩余时间为: " + $('#countdown').html() + "\n";
    } else {
      msg += "使用时间为： " + $('#countdown').html() + "\n";
    }
    msg += "得分为： " + $('#score').html() + "\n";
    return alert(msg);
  };


  /*
    扫描变色块
   */

  this.scanChange = function() {
    var c, k, m, o, ref, ref1, results;
    for (k = m = 0, ref = this.colorsSum; 0 <= ref ? m < ref : m > ref; k = 0 <= ref ? ++m : --m) {
      if (k === this.targetColor) {
        continue;
      }
      checkOneColor(k, false);
      checkOneColor(this.targetColor, false);
    }
    results = [];
    for (c = o = 0, ref1 = this.colorsSum; 0 <= ref1 ? o < ref1 : o > ref1; c = 0 <= ref1 ? ++o : --o) {
      results.push(resetScanState(c));
    }
    return results;
  };


  /*
    重置扫描状态
   */

  this.resetScanState = function(colorIndex) {
    var i, j, m, ref, results;
    results = [];
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      results.push((function() {
        var o, ref1, results1;
        results1 = [];
        for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
          results1.push(this.cells[i][j].cellFlags[colorIndex].hadScan = false);
        }
        return results1;
      }).call(this));
    }
    return results;
  };


  /*
    检测一种颜色变色情况
   */

  this.checkOneColor = function(colorIndex, isPlay) {
    var i, j, m, ref, results, scanCells;
    colorIndex = parseInt(colorIndex);
    results = [];
    for (i = m = 0, ref = this.mShape.i; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      results.push((function() {
        var o, ref1, results1;
        results1 = [];
        for (j = o = 0, ref1 = this.mShape.j; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
          if (this.cells[i][j].cellFlags[colorIndex].hadScan || parseInt(this.cells[i][j].color) === colorIndex) {
            this.cells[i][j].cellFlags[colorIndex].hadScan = true;
            continue;
          }
          scanCells = scanOneCell(i, j, colorIndex);
          if (judgeChange(scanCells)) {
            results1.push(changeColors(scanCells, colorIndex, isPlay));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };


  /*
   以一个起点扫描
   */

  this.scanOneCell = function(i, j, colorIndex) {
    var queue, scanCells, site, x, y;
    i = parseInt(i);
    j = parseInt(j);
    colorIndex = parseInt(colorIndex);
    queue = [];
    scanCells = [];
    this.cells[i][j].cellFlags[colorIndex].hadScan = true;
    queue.push({
      'i': i,
      'j': j
    });
    while (queue.length > 0) {
      site = queue.shift();
      x = site.i;
      y = site.j;
      if ((y - 1 >= 0) && (parseInt(this.cells[x][y - 1].color) !== colorIndex) && (!this.cells[x][y - 1].cellFlags[colorIndex].hadScan)) {
        this.cells[x][y - 1].cellFlags[colorIndex].hadScan = true;
        queue.push({
          'i': x,
          'j': y - 1
        });
      }
      if ((x - 1 >= 0) && (parseInt(this.cells[x - 1][y].color) !== colorIndex) && (!this.cells[x - 1][y].cellFlags[colorIndex].hadScan)) {
        this.cells[x - 1][y].cellFlags[colorIndex].hadScan = true;
        queue.push({
          'i': x - 1,
          'j': y
        });
      }
      if ((y + 1 < this.mShape.j) && (parseInt(this.cells[x][y + 1].color) !== colorIndex) && (!this.cells[x][y + 1].cellFlags[colorIndex].hadScan)) {
        this.cells[x][y + 1].cellFlags[colorIndex].hadScan = true;
        queue.push({
          'i': x,
          'j': y + 1
        });
      }
      if ((x + 1 < this.mShape.i) && (parseInt(this.cells[x + 1][y].color) !== colorIndex) && (!this.cells[x + 1][y].cellFlags[colorIndex].hadScan)) {
        this.cells[x + 1][y].cellFlags[colorIndex].hadScan = true;
        queue.push({
          'i': x + 1,
          'j': y
        });
      }
      scanCells.push(site);
    }
    return scanCells;
  };


  /*
    分开判断变色
   */

  this.judgeChange = function(scanCells) {
    var down, l, left, m, minEdge, ref, right, s, up;
    minEdge = this.mShape.i > this.mShape.j ? this.mShape.j : this.mShape.i;
    if (scanCells.length < minEdge / 2 + 1) {
      return true;
    } else {
      left = 0;
      right = 0;
      up = 0;
      down = 0;
      for (l = m = 0, ref = scanCells.length; 0 <= ref ? m < ref : m > ref; l = 0 <= ref ? ++m : --m) {
        s = scanCells[l];
        if (s.j === 0) {
          left++;
        }
        if (s.j === (this.mShape.j - 1)) {
          right++;
        }
        if (s.i === 0) {
          up++;
        }
        if (s.i === (this.mShape.i - 1)) {
          down++;
        }
      }
      if (left > 0 && right > 0 && up > 0 && down > 0) {
        return false;
      } else if ((left > 0 && right > 0 && up > 0) && (left > 0 && right > 0 && down > 0) && (left > 0 && up > 0 && down > 0) && (right > 0 && up > 0 && down > 0)) {
        return false;
      } else if (left + right + up + down > ((this.mShape.i + this.mShape.j) / 2)) {
        return false;
      } else {
        return true;
      }
    }
  };


  /*
    改变颜色
   */

  this.changeColors = function(scanCells, color, isPlay) {
    var i, j, len, m, n, results, s, score;
    n = scanCells.length;
    color = parseInt(color);
    if (isPlay && color === this.targetColor) {
      this.targetColorSum += scanCells.length;
      score = parseInt($('#score').html());
      score += n === 1 ? 100 : (100 + 100 + (n - 1) * 20) * n / 2;
      $('#score').html(score);
    }
    results = [];
    for (m = 0, len = scanCells.length; m < len; m++) {
      s = scanCells[m];
      i = s.i;
      j = s.j;
      this.cells[i][j].color = color;
      results.push(setColor(structId(i, j), this.colors[color], color));
    }
    return results;
  };

}).call(this);

//# sourceMappingURL=demo.js.map
